---
id: hot100
title: HOT 100
# hide_title: false
# hide_table_of_contents: false
# sidebar_label: Markdown :)
# custom_edit_url: https://github.com/facebook/docusaurus/edit/master/docs/api-doc-markdown.md
description: LeetCode 热题 HOT 100
keywords:
  - JavaScript
  - Java
  - 数据结构和算法
# image: https://i.imgur.com/mErPwqL.png
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

### 我的题解

#### 解题思路

直接暴力枚举两层 for 循环，判断相加是否与 target 相等

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = 0; j < nums.length; j++) {
      if (i !== j) {
        if (nums[i] + nums[j] === target) return [i, j];
      }
    }
  }
};
```

</TabItem>
<TabItem value="java">

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        int[] arr = new int[2];
        for (int i = 0; i < nums.length; i++) {
            for(int j = 0 ;j < nums.length ;j++) {
                if( i != j ) {
                    if(nums[i] + nums[j] == target){
                        arr[0] = i;
                        arr[1] = j;
                    }
                }
            }
        }
        return arr;
    }
}
```

</TabItem>
</Tabs>

### leetcode 题解

#### 解题思路

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var twoSum = function (nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i];
    }
    map.set(nums[i], i);
  }
  return [];
};
```

</TabItem>
<TabItem value="java">

```java
class Solution {
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            if(hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]),i};
            }
            hashtable.put(nums[i],i);
        }
        return new int[0];
    }
}
```

</TabItem>
</Tabs>

## 2.两数相加

### 我的题解

#### 解题思路

先遍历两个链表，按权值乘每位数字，最后相加得到相加后的结果。然后使用栈方法，将结果的数字从低位到高位一个一个出栈。

注意计算$10^{n}$时需处理大数问题

#### 代码

```js
var addTwoNumbers = function (l1, l2) {
  let p1 = l1;
  let p2 = l2;
  let pow1 = 0;
  let pow2 = 0;
  let result = 0n;

  while (p1 !== null) {
    let pows = 1n;
    for (let i = 0; i < pow1; i++) {
      pows *= 10n;
    }
    result += pows * BigInt(p1.val);
    pow1++;
    p1 = p1.next;
  }
  while (p2 !== null) {
    let pows = 1n;
    for (let i = 0; i < pow2; i++) {
      pows *= 10n;
    }
    result += pows * BigInt(p2.val);
    pow2++;
    p2 = p2.next;
  }
  result = result.toString().split("");
  if (result.length === 1) {
    return new ListNode(result.pop(), null);
  } else {
    const head = new ListNode(result.pop(), null);
    let p = head;
    while (result.length) {
      const node = new ListNode(result.pop(), null);
      p.next = node;
      p = node;
    }
    return head;
  }
};
```

### leetcode 题解

#### 解题思路

由于输入的两个链表都是**逆序**存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。

我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为$n1,n2$，进位值为 $\textit{carry}$，则它们的和为 $n1+n2+\textit{carry}$；其中，答案链表处相应位置的数字为$(n1+n2+\textit{carry}) \% 10$，而新的进位值为 $\lfloor\frac{n1+n2+\textit{carry}}{10}\rfloor$。

如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个$0$ 。

此外，如果链表遍历结束后，有$\textit{carry} > 0$，还需要在答案链表的后面附加一个节点，节点的值为 $\textit{carry}$。

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var addTwoNumbers = function (l1, l2) {
  let head = null,
    tail = null;
  let carry = 0;
  while (l1 || l2) {
    const n1 = l1 ? l1.val : 0;
    const n2 = l2 ? l2.val : 0;
    const sum = n1 + n2 + carry;
    if (!head) {
      head = tail = new ListNode(sum % 10);
    } else {
      tail.next = new ListNode(sum % 10);
      tail = tail.next;
    }
    carry = Math.floor(sum / 10);
    if (l1) {
      l1 = l1.next;
    }
    if (l2) {
      l2 = l2.next;
    }
  }
  if (carry > 0) {
    tail.next = new ListNode(carry);
  }
  return head;
};
```

</TabItem>
<TabItem value="java">

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}
```

</TabItem>
</Tabs>

## 3.无重复字符的最长子串

### leetcode 题解

#### 解题思路

这道题主要用到思路是：滑动窗口

什么是滑动窗口？

其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var lengthOfLongestSubstring = function (s) {
  const occ = new Set();
  let ans = 0,
    rk = -1;
  let len = s.length;
  for (let i = 0; i < len; i++) {
    if (i != 0) {
      occ.delete(s.charAt(i - 1));
    }
    while (rk + 1 < len && !occ.has(s.charAt(rk + 1))) {
      occ.add(s.charAt(rk + 1));
      rk++;
    }
    ans = Math.max(ans, rk - i + 1);
  }
  return ans;
};
```

</TabItem>
<TabItem value="java">

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> occ = new HashSet<Character>();
        int ans = 0, rk = -1;
        int len = s.length();
        for (int i = 0; i < len; i++) {
            if (i != 0) {
                occ.remove(s.charAt(i - 1));
            }
            while (rk + 1 < len && !occ.contains(s.charAt(rk + 1))) {
                occ.add(s.charAt(rk + 1));
                rk++;
            }
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}
```

</TabItem>
</Tabs>

## 4.寻找两个正序数组的中位数

### 我的题解

#### 解题思路

首先把两个正序数组合并成一个正序数组，然后再求中位数。

#### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        double mid = 0;
        int len = nums1.length + nums2.length;
        int[] nums = new int[len];
        int i = 0, j = 0, k = 0;
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] <= nums2[j]) {
                nums[k] = nums1[i];
                i++;
            } else {
                nums[k] = nums2[j];
                j++;
            }
            k++;
        }
        while (i < nums1.length) {
            nums[k] = nums1[i];
            i++;
            k++;
        }
        while (j < nums2.length) {
            nums[k] = nums2[j];
            j++;
            k++;
        }
        if (len % 2 != 0) {
            mid = nums[(len + 1) / 2 - 1];
        } else {
            mid = (double) (nums[len / 2 - 1] + nums[len / 2]) / 2;
        }
        return mid;
    }
}
```

### leetcode 题解

#### 解题思路

采用二分法，假设两个有序数组分别为 $\text{A}$、$\text{B}$，找到它们的中位数等同于找到它们第 $k$ 小的数为 $(m+n)/2$ 或 $(m+n)/2+1$。

由于 $\text{A}[k/2-1]$ 和 $\text{B}[k/2 - 1]$ 前面有 $\text{A}[0..k/2-2]$ 和 $\text{B}[0..k/2-2]$个元素，即 $(k/2-1)$ + $(k/2-1)$ = $k/2$，所以不是第 $k$ 个数。

所以可以比较 $\text{A}[k/2-1]$ 和 $\text{B}[k/2-1]$，有以下三种情况

![20210128-154424-0477.png](https://gitee.com/cansiny0320/file-bed/raw/master/20210128-154424-0477.png)

可以看到比较$A[k/2 - 1]$ 和 $B[k/2 - 1]$后，排除了 $k/2$个不是第 $k$ 小的数。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 $k$ 的值，这是因为我们排除的数都不大于第 $k$ 小的数。

有三种边界情况需要注意

如果 $\text{A}[k/2-1]$ 或者 $\text{B}[k/2-1]$ 越界，那么我们可以选取对应数组中的最后一个元素。

如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 $k$ 小的元素。

如果 $k=1$，我们只要返回两个数组首元素的最小值即可。

#### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        double median;
        if (totalLength % 2 != 0) {
            int midIndex = totalLength / 2;
            median = getKthElement(nums1, nums2, midIndex + 1);
        } else {
            int midIndex1 = totalLength / 2, midIndex2 = totalLength / 2 - 1;
            median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
        }
        return median;
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        int index1 = 0, index2 = 0;
        int length1 = nums1.length, length2 = nums2.length;
        int kthElement = 0;
        while (true) {
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }

            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }

    }
}
```

## 5.最长回文子串

### leetcode 题解

#### 解题思路

方法：动态规划

- 状态：dp[i][j] 表示字串 s[i..j] 是否为回文串
- 状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
  边界条件：(j - 1) - (i + 1) + 1 < 2，整理得 j - i < 3
- 初始化：dp[i][j] = true
- 输出：在得到一个状态的值为 true 的时候，记录起始位置和长度，填表完成以后再截取

#### 代码

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        int maxLen = 1;
        int begin = 0;

        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArr = s.toCharArray();
        for (int j = 1; j < len; j++) {
            for (int i = 0; i < j; i++) {
                if (charArr[i] != charArr[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```
