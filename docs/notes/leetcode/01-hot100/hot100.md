---
id: hot100
title: HOT 100
# hide_title: false
# hide_table_of_contents: false
# sidebar_label: Markdown :)
# custom_edit_url: https://github.com/facebook/docusaurus/edit/master/docs/api-doc-markdown.md
description: LeetCode 热题 HOT 100
keywords:
  - JavaScript
  - Java
  - 数据结构和算法
# image: https://i.imgur.com/mErPwqL.png
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

### 我的题解

#### 解题思路

直接暴力枚举两层 for 循环，判断相加是否与 target 相等

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = 0; j < nums.length; j++) {
      if (i !== j) {
        if (nums[i] + nums[j] === target) return [i, j]
      }
    }
  }
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        int[] arr = new int[2];
        for (int i = 0; i < nums.length; i++) {
            for(int j = 0 ;j < nums.length ;j++) {
                if( i != j ) {
                    if(nums[i] + nums[j] == target){
                        arr[0] = i;
                        arr[1] = j;
                    }
                }
            }
        }
        return arr;
    }
}
```

</TabItem>
</Tabs>

### leetcode 题解

#### 解题思路

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var twoSum = function (nums, target) {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i]
    }
    map.set(nums[i], i)
  }
  return []
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            if(hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]),i};
            }
            hashtable.put(nums[i],i);
        }
        return new int[0];
    }
}
```

</TabItem>
</Tabs>

## 2.两数相加

### 我的题解

#### 解题思路

先遍历两个链表，按权值乘每位数字，最后相加得到相加后的结果。然后使用栈方法，将结果的数字从低位到高位一个一个出栈。

注意计算$10^{n}$时需处理大数问题

#### 代码

```js
var addTwoNumbers = function (l1, l2) {
  let p1 = l1
  let p2 = l2
  let pow1 = 0
  let pow2 = 0
  let result = 0n

  while (p1 !== null) {
    let pows = 1n
    for (let i = 0; i < pow1; i++) {
      pows *= 10n
    }
    result += pows * BigInt(p1.val)
    pow1++
    p1 = p1.next
  }
  while (p2 !== null) {
    let pows = 1n
    for (let i = 0; i < pow2; i++) {
      pows *= 10n
    }
    result += pows * BigInt(p2.val)
    pow2++
    p2 = p2.next
  }
  result = result.toString().split('')
  if (result.length === 1) {
    return new ListNode(result.pop(), null)
  } else {
    const head = new ListNode(result.pop(), null)
    let p = head
    while (result.length) {
      const node = new ListNode(result.pop(), null)
      p.next = node
      p = node
    }
    return head
  }
}
```

### leetcode 题解

#### 解题思路

由于输入的两个链表都是**逆序**存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。

我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为$n1,n2$，进位值为 $\textit{carry}$，则它们的和为 $n1+n2+\textit{carry}$；其中，答案链表处相应位置的数字为$(n1+n2+\textit{carry}) \% 10$，而新的进位值为 $\lfloor\frac{n1+n2+\textit{carry}}{10}\rfloor$。

如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个$0$ 。

此外，如果链表遍历结束后，有$\textit{carry} > 0$，还需要在答案链表的后面附加一个节点，节点的值为 $\textit{carry}$。

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var addTwoNumbers = function (l1, l2) {
  let head = null,
    tail = null
  let carry = 0
  while (l1 || l2) {
    const n1 = l1 ? l1.val : 0
    const n2 = l2 ? l2.val : 0
    const sum = n1 + n2 + carry
    if (!head) {
      head = tail = new ListNode(sum % 10)
    } else {
      tail.next = new ListNode(sum % 10)
      tail = tail.next
    }
    carry = Math.floor(sum / 10)
    if (l1) {
      l1 = l1.next
    }
    if (l2) {
      l2 = l2.next
    }
  }
  if (carry > 0) {
    tail.next = new ListNode(carry)
  }
  return head
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}
```

</TabItem>
</Tabs>

## 3.无重复字符的最长子串

### leetcode 题解

#### 解题思路

这道题主要用到思路是：滑动窗口

什么是滑动窗口？

其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var lengthOfLongestSubstring = function (s) {
  const occ = new Set()
  let ans = 0,
    rk = -1
  let len = s.length
  for (let i = 0; i < len; i++) {
    if (i != 0) {
      occ.delete(s.charAt(i - 1))
    }
    while (rk + 1 < len && !occ.has(s.charAt(rk + 1))) {
      occ.add(s.charAt(rk + 1))
      rk++
    }
    ans = Math.max(ans, rk - i + 1)
  }
  return ans
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> occ = new HashSet<Character>();
        int ans = 0, rk = -1;
        int len = s.length();
        for (int i = 0; i < len; i++) {
            if (i != 0) {
                occ.remove(s.charAt(i - 1));
            }
            while (rk + 1 < len && !occ.contains(s.charAt(rk + 1))) {
                occ.add(s.charAt(rk + 1));
                rk++;
            }
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}
```

</TabItem>
</Tabs>

## 4.寻找两个正序数组的中位数

### 我的题解

#### 解题思路

首先把两个正序数组合并成一个正序数组，然后再求中位数。

#### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        double mid = 0;
        int len = nums1.length + nums2.length;
        int[] nums = new int[len];
        int i = 0, j = 0, k = 0;
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] <= nums2[j]) {
                nums[k] = nums1[i];
                i++;
            } else {
                nums[k] = nums2[j];
                j++;
            }
            k++;
        }
        while (i < nums1.length) {
            nums[k] = nums1[i];
            i++;
            k++;
        }
        while (j < nums2.length) {
            nums[k] = nums2[j];
            j++;
            k++;
        }
        if (len % 2 != 0) {
            mid = nums[(len + 1) / 2 - 1];
        } else {
            mid = (double) (nums[len / 2 - 1] + nums[len / 2]) / 2;
        }
        return mid;
    }
}
```

### leetcode 题解

#### 解题思路

采用二分法，假设两个有序数组分别为 $\text{A}$、$\text{B}$，找到它们的中位数等同于找到它们第 $k$ 小的数为 $(m+n)/2$ 或 $(m+n)/2+1$。

由于 $\text{A}[k/2-1]$ 和 $\text{B}[k/2 - 1]$ 前面有 $\text{A}[0..k/2-2]$ 和 $\text{B}[0..k/2-2]$个元素，即 $(k/2-1)$ + $(k/2-1)$ = $k/2$，所以不是第 $k$ 个数。

所以可以比较 $\text{A}[k/2-1]$ 和 $\text{B}[k/2-1]$，有以下三种情况

![20210128-154424-0477.png](https://gitee.com/cansiny0320/file-bed/raw/master/20210128-154424-0477.png)

可以看到比较$\text{A}[k/2 - 1]$ 和 $\text{B}[k/2 - 1]$后，排除了 $k/2$个不是第 $k$ 小的数。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 $k$ 的值，这是因为我们排除的数都不大于第 $k$ 小的数。

有三种边界情况需要注意

如果 $\text{A}[k/2-1]$ 或者 $\text{B}[k/2-1]$ 越界，那么我们可以选取对应数组中的最后一个元素。

如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 $k$ 小的元素。

如果 $k=1$，我们只要返回两个数组首元素的最小值即可。

#### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        double median;
        if (totalLength % 2 != 0) {
            int midIndex = totalLength / 2;
            median = getKthElement(nums1, nums2, midIndex + 1);
        } else {
            int midIndex1 = totalLength / 2, midIndex2 = totalLength / 2 - 1;
            median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
        }
        return median;
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        int index1 = 0, index2 = 0;
        int length1 = nums1.length, length2 = nums2.length;
        int kthElement = 0;
        while (true) {
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }

            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }

    }
}
```

## 5.最长回文子串

### leetcode 题解

#### 解题思路

方法：动态规划

- 状态：$\text{dp}[i][j]$ 表示字串 $\text{s}[i..j]$ 是否为回文串
- 状态转移方程：$\text{dp}[i][j]$ $=$ $($$\text{s}[i]$ $==$ $\text{s}[j]$$)$ $and$ $\text{dp}[i + 1][j - 1]$

  边界条件：$(j - 1) - (i + 1) + 1 < 2$，整理得 $j - i < 3$

- 初始化：$\text{dp}[i][j]$ $=$ $\text{true}$
- 输出：在得到一个状态的值为 $\text{true}$ 的时候，记录起始位置和长度，填表完成以后再截取

#### 代码

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        int maxLen = 1;
        int begin = 0;

        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArr = s.toCharArray();
        for (int j = 1; j < len; j++) {
            for (int i = 0; i < j; i++) {
                if (charArr[i] != charArr[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```

## 10. 正则表达式匹配

### leetcode 题解

方法：状态转移

- 状态$f[i][j]$表示$s$的前$i$个字符与$p$的前$j$个字符是否能匹配
- 状态转移方程：

  $$
  f[i][j] = \begin{cases} \text{if}(p[j] \neq '\text{*}') = \begin{cases} f[i-1][j-1] , & matches(s[i],p[j]) \\ \text{false} , & otherwise \end{cases} \\ otherwise = \begin{cases} f[i-1][j] \text{or} f[i][j-2] , & matches(s[i],p[j-1]) \\ f[i][j-2] , & otherwise \end{cases}\end{cases}
  $$

- 边界条件：$f[0][0] = \text{true}$
- 输出：$f[m][n]$

#### 代码

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p.charAt(j - 1) == '*') {
                    f[i][j] = f[i][j - 2];
                    if (matches(s, p, i, j - 1)) {
                        f[i][j] = f[i][j] || f[i - 1][j];
                    }
                } else {
                    if (matches(s, p, i, j)) {
                        f[i][j] = f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }

    public boolean matches(String s, String p, int i, int j) {
        if (i == 0) {
            return false;
        }
        if (p.charAt(j - 1) == '.') {
            return true;
        }
        return s.charAt(i - 1) == p.charAt(j - 1);
    }
}
```

## 11.盛最多水的容器

### leetcode 题解

#### 思路

方法：双指针

两个指针$left$和$right$分别指向头尾两个数，移动较小的数，遇到比自身大的数时，计算面积，比较左右指针所指的数的大小，再次移动较小的数。

#### 代码

```java
class Solution {
    public int maxArea(int[] height) {
        int len = height.length;
        int left = 0, right = len - 1;
        int maxarea = Math.min(height[left], height[right]) * (right - left);
        boolean leftRun = height[left] < height[right];
        while (left < right) {
            if (leftRun) {
                int newLeft = left;
                do {
                    newLeft++;
                    if (height[left] < height[newLeft]) {
                        left = newLeft;
                        int low = Math.min(height[left], height[right]);
                        maxarea = Math.max(maxarea, low * (right - left));
                        leftRun = height[left] < height[right];
                        break;
                    }
                } while (newLeft < right);
                if (newLeft == right) break;
            } else {
                int newRight = right;
                do {
                    newRight--;
                    if (height[right] < height[newRight]) {
                        right = newRight;
                        int low = Math.min(height[left], height[right]);
                        maxarea = Math.max(maxarea, low * (right - left));
                        leftRun = height[left] < height[right];
                        break;
                    }
                } while (left < newRight);
                if (newRight == left) break;
            }
        }
        return maxarea;
    }
}
```

## 15.三数之和

### leetcode 题解

#### 解题思路

排序 + 双指针

首先固定一个数，这样问题就转化成了求解两数之和，然后使用双指针求解，首先要将数组进行排序，遍历排序后数组：

- 若 $nums[i] > 0$：因为已经排序好，所以后面不可能有三个数加和等于 $0$，直接返回结果。

- 对于重复元素：跳过，避免出现重复解

- 令左指针 $L=i+1$，右指针 $R=n-1$，当 $L<R$ 时，执行循环：

  - 当 $nums[i]+nums[L]+nums[R]==0$，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 $L,R$ 移到下一位置，寻找新的解

  - 若和大于 $0$，说明 $nums[R]$ 太大，$R$ 左移

  - 若和小于 $0$，说明 $nums[L]$ 太小，$L$ 右移

#### 代码

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        if (nums == null || nums.length <= 2) return ans;

        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i++) {
            if (nums[i] > 0) break; // 第一个数大于 0，后面的数都比它大，肯定不成立了
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 去掉重复情况
            int target = -nums[i];
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                if (nums[left] + nums[right] == target) {
                    ans.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));

                    // 现在要增加 left，减小 right
                    left++;
                    right--; // 首先无论如何先要进行加减操作
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } else if (nums[left] + nums[right] < target) {
                    left++;
                } else {  // nums[left] + nums[right] > target
                    right--;
                }
            }
        }
        return ans;
    }
}
```

## 17.电话号码的字母组合

### leetcode 题解

#### 解题思路

首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。

回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。

回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。

#### 代码

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }

    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        } else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            int lettersCount = letters.length();
            for (int i = 0; i < lettersCount; i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}
```

## 22.括号生成

### leetcode 题解

#### 解题思路

回溯算法(深度优先遍历)

![](https://pic.leetcode-cn.com/efbe574e5e6addcd1c9dc5c13a50c6f162a2b14a95d6aed2c394e18287a067fa-image.png)

#### 代码

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<String>();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max) {
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }
        if (open < max) {
            cur.append("(");
            backtrack(ans, cur, open + 1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }

        if (close < open) {
            cur.append(")");
            backtrack(ans, cur, open, close + 1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
```
