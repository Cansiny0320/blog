---
id: hot100
title: HOT 100
hide_title: true
# hide_table_of_contents: false
# sidebar_label: Markdown :)
# custom_edit_url: https://github.com/facebook/docusaurus/edit/master/docs/api-doc-markdown.md
description: LeetCode 热题 HOT 100
keywords:
  - JavaScript
  - Java
  - 数据结构和算法
# image: https://i.imgur.com/mErPwqL.png
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

### 我的题解

#### 解题思路

直接暴力枚举两层 for 循环，判断相加是否与 target 相等

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = 0; j < nums.length; j++) {
      if (i !== j) {
        if (nums[i] + nums[j] === target) return [i, j]
      }
    }
  }
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        int[] arr = new int[2];
        for (int i = 0; i < nums.length; i++) {
            for(int j = 0 ;j < nums.length ;j++) {
                if( i != j ) {
                    if(nums[i] + nums[j] == target){
                        arr[0] = i;
                        arr[1] = j;
                    }
                }
            }
        }
        return arr;
    }
}
```

</TabItem>
</Tabs>

### leetcode 题解

#### 解题思路

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var twoSum = function (nums, target) {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i]
    }
    map.set(nums[i], i)
  }
  return []
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            if(hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]),i};
            }
            hashtable.put(nums[i],i);
        }
        return new int[0];
    }
}
```

</TabItem>
</Tabs>

## 2.两数相加

### 我的题解

#### 解题思路

先遍历两个链表，按权值乘每位数字，最后相加得到相加后的结果。然后使用栈方法，将结果的数字从低位到高位一个一个出栈。

注意计算$10^{n}$时需处理大数问题

#### 代码

```js
var addTwoNumbers = function (l1, l2) {
  let p1 = l1
  let p2 = l2
  let pow1 = 0
  let pow2 = 0
  let result = 0n

  while (p1 !== null) {
    let pows = 1n
    for (let i = 0; i < pow1; i++) {
      pows *= 10n
    }
    result += pows * BigInt(p1.val)
    pow1++
    p1 = p1.next
  }
  while (p2 !== null) {
    let pows = 1n
    for (let i = 0; i < pow2; i++) {
      pows *= 10n
    }
    result += pows * BigInt(p2.val)
    pow2++
    p2 = p2.next
  }
  result = result.toString().split('')
  if (result.length === 1) {
    return new ListNode(result.pop(), null)
  } else {
    const head = new ListNode(result.pop(), null)
    let p = head
    while (result.length) {
      const node = new ListNode(result.pop(), null)
      p.next = node
      p = node
    }
    return head
  }
}
```

### leetcode 题解

#### 解题思路

由于输入的两个链表都是**逆序**存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。

我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为$n1,n2$，进位值为 $\textit{carry}$，则它们的和为 $n1+n2+\textit{carry}$；其中，答案链表处相应位置的数字为$(n1+n2+\textit{carry}) \% 10$，而新的进位值为 $\lfloor\frac{n1+n2+\textit{carry}}{10}\rfloor$。

如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个$0$ 。

此外，如果链表遍历结束后，有$\textit{carry} > 0$，还需要在答案链表的后面附加一个节点，节点的值为 $\textit{carry}$。

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var addTwoNumbers = function (l1, l2) {
  let head = null,
    tail = null
  let carry = 0
  while (l1 || l2) {
    const n1 = l1 ? l1.val : 0
    const n2 = l2 ? l2.val : 0
    const sum = n1 + n2 + carry
    if (!head) {
      head = tail = new ListNode(sum % 10)
    } else {
      tail.next = new ListNode(sum % 10)
      tail = tail.next
    }
    carry = Math.floor(sum / 10)
    if (l1) {
      l1 = l1.next
    }
    if (l2) {
      l2 = l2.next
    }
  }
  if (carry > 0) {
    tail.next = new ListNode(carry)
  }
  return head
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}
```

</TabItem>
</Tabs>

## 3.无重复字符的最长子串

### leetcode 题解

#### 解题思路

这道题主要用到思路是：滑动窗口

什么是滑动窗口？

其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

#### 代码

<Tabs
defaultValue="js"
values={[
{ label: 'JavaScript', value: 'js', },
{ label: 'Java', value: 'java', },
]
}>
<TabItem value="js">

```js
var lengthOfLongestSubstring = function (s) {
  const occ = new Set()
  let ans = 0,
    rk = -1
  let len = s.length
  for (let i = 0; i < len; i++) {
    if (i != 0) {
      occ.delete(s.charAt(i - 1))
    }
    while (rk + 1 < len && !occ.has(s.charAt(rk + 1))) {
      occ.add(s.charAt(rk + 1))
      rk++
    }
    ans = Math.max(ans, rk - i + 1)
  }
  return ans
}
```

</TabItem>
<TabItem value="java">

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> occ = new HashSet<Character>();
        int ans = 0, rk = -1;
        int len = s.length();
        for (int i = 0; i < len; i++) {
            if (i != 0) {
                occ.remove(s.charAt(i - 1));
            }
            while (rk + 1 < len && !occ.contains(s.charAt(rk + 1))) {
                occ.add(s.charAt(rk + 1));
                rk++;
            }
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}
```

</TabItem>
</Tabs>

## 4.寻找两个正序数组的中位数

### 我的题解

#### 解题思路

首先把两个正序数组合并成一个正序数组，然后再求中位数。

#### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        double mid = 0;
        int len = nums1.length + nums2.length;
        int[] nums = new int[len];
        int i = 0, j = 0, k = 0;
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] <= nums2[j]) {
                nums[k] = nums1[i];
                i++;
            } else {
                nums[k] = nums2[j];
                j++;
            }
            k++;
        }
        while (i < nums1.length) {
            nums[k] = nums1[i];
            i++;
            k++;
        }
        while (j < nums2.length) {
            nums[k] = nums2[j];
            j++;
            k++;
        }
        if (len % 2 != 0) {
            mid = nums[(len + 1) / 2 - 1];
        } else {
            mid = (double) (nums[len / 2 - 1] + nums[len / 2]) / 2;
        }
        return mid;
    }
}
```

### leetcode 题解

#### 解题思路

采用二分法，假设两个有序数组分别为 $\text{A}$、$\text{B}$，找到它们的中位数等同于找到它们第 $k$ 小的数为 $(m+n)/2$ 或 $(m+n)/2+1$。

由于 $\text{A}[k/2-1]$ 和 $\text{B}[k/2 - 1]$ 前面有 $\text{A}[0..k/2-2]$ 和 $\text{B}[0..k/2-2]$个元素，即 $(k/2-1)$ + $(k/2-1)$ = $k/2$，所以不是第 $k$ 个数。

所以可以比较 $\text{A}[k/2-1]$ 和 $\text{B}[k/2-1]$，有以下三种情况

![20210128-154424-0477.png](https://gitee.com/cansiny0320/file-bed/raw/master/20210128-154424-0477.png)

可以看到比较$\text{A}[k/2 - 1]$ 和 $\text{B}[k/2 - 1]$后，排除了 $k/2$个不是第 $k$ 小的数。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 $k$ 的值，这是因为我们排除的数都不大于第 $k$ 小的数。

有三种边界情况需要注意

如果 $\text{A}[k/2-1]$ 或者 $\text{B}[k/2-1]$ 越界，那么我们可以选取对应数组中的最后一个元素。

如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 $k$ 小的元素。

如果 $k=1$，我们只要返回两个数组首元素的最小值即可。

#### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        double median;
        if (totalLength % 2 != 0) {
            int midIndex = totalLength / 2;
            median = getKthElement(nums1, nums2, midIndex + 1);
        } else {
            int midIndex1 = totalLength / 2, midIndex2 = totalLength / 2 - 1;
            median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
        }
        return median;
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        int index1 = 0, index2 = 0;
        int length1 = nums1.length, length2 = nums2.length;
        int kthElement = 0;
        while (true) {
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }

            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }

    }
}
```

## 5.最长回文子串

### leetcode 题解

#### 解题思路

方法：动态规划

- 状态：$\text{dp}[i][j]$ 表示字串 $\text{s}[i..j]$ 是否为回文串
- 状态转移方程：$\text{dp}[i][j]$ $=$ $($$\text{s}[i]$ $==$ $\text{s}[j]$$)$ $and$ $\text{dp}[i + 1][j - 1]$

  边界条件：$(j - 1) - (i + 1) + 1 < 2$，整理得 $j - i < 3$

- 初始化：$\text{dp}[i][j]$ $=$ $\text{true}$
- 输出：在得到一个状态的值为 $\text{true}$ 的时候，记录起始位置和长度，填表完成以后再截取

#### 代码

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        int maxLen = 1;
        int begin = 0;

        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArr = s.toCharArray();
        for (int j = 1; j < len; j++) {
            for (int i = 0; i < j; i++) {
                if (charArr[i] != charArr[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```

## 10. 正则表达式匹配

### leetcode 题解

方法：状态转移

- 状态$f[i][j]$表示$s$的前$i$个字符与$p$的前$j$个字符是否能匹配
- 状态转移方程：

  $$
  f[i][j] = \begin{cases} \text{if}(p[j] \neq '\text{*}') = \begin{cases} f[i-1][j-1] , & matches(s[i],p[j]) \\ \text{false} , & otherwise \end{cases} \\ otherwise = \begin{cases} f[i-1][j] \text{or} f[i][j-2] , & matches(s[i],p[j-1]) \\ f[i][j-2] , & otherwise \end{cases}\end{cases}
  $$

- 边界条件：$f[0][0] = \text{true}$
- 输出：$f[m][n]$

#### 代码

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p.charAt(j - 1) == '*') {
                    f[i][j] = f[i][j - 2];
                    if (matches(s, p, i, j - 1)) {
                        f[i][j] = f[i][j] || f[i - 1][j];
                    }
                } else {
                    if (matches(s, p, i, j)) {
                        f[i][j] = f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }

    public boolean matches(String s, String p, int i, int j) {
        if (i == 0) {
            return false;
        }
        if (p.charAt(j - 1) == '.') {
            return true;
        }
        return s.charAt(i - 1) == p.charAt(j - 1);
    }
}
```

## 11.盛最多水的容器

### leetcode 题解

#### 思路

方法：双指针

两个指针$left$和$right$分别指向头尾两个数，移动较小的数，遇到比自身大的数时，计算面积，比较左右指针所指的数的大小，再次移动较小的数。

#### 代码

```java
class Solution {
    public int maxArea(int[] height) {
        int len = height.length;
        int left = 0, right = len - 1;
        int maxarea = Math.min(height[left], height[right]) * (right - left);
        boolean leftRun = height[left] < height[right];
        while (left < right) {
            if (leftRun) {
                int newLeft = left;
                do {
                    newLeft++;
                    if (height[left] < height[newLeft]) {
                        left = newLeft;
                        int low = Math.min(height[left], height[right]);
                        maxarea = Math.max(maxarea, low * (right - left));
                        leftRun = height[left] < height[right];
                        break;
                    }
                } while (newLeft < right);
                if (newLeft == right) break;
            } else {
                int newRight = right;
                do {
                    newRight--;
                    if (height[right] < height[newRight]) {
                        right = newRight;
                        int low = Math.min(height[left], height[right]);
                        maxarea = Math.max(maxarea, low * (right - left));
                        leftRun = height[left] < height[right];
                        break;
                    }
                } while (left < newRight);
                if (newRight == left) break;
            }
        }
        return maxarea;
    }
}
```

## 15.三数之和

### leetcode 题解

#### 解题思路

排序 + 双指针

首先固定一个数，这样问题就转化成了求解两数之和，然后使用双指针求解，首先要将数组进行排序，遍历排序后数组：

- 若 $nums[i] > 0$：因为已经排序好，所以后面不可能有三个数加和等于 $0$，直接返回结果。

- 对于重复元素：跳过，避免出现重复解

- 令左指针 $L=i+1$，右指针 $R=n-1$，当 $L<R$ 时，执行循环：

  - 当 $nums[i]+nums[L]+nums[R]==0$，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 $L,R$ 移到下一位置，寻找新的解

  - 若和大于 $0$，说明 $nums[R]$ 太大，$R$ 左移

  - 若和小于 $0$，说明 $nums[L]$ 太小，$L$ 右移

#### 代码

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        if (nums == null || nums.length <= 2) return ans;

        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i++) {
            if (nums[i] > 0) break; // 第一个数大于 0，后面的数都比它大，肯定不成立了
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 去掉重复情况
            int target = -nums[i];
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                if (nums[left] + nums[right] == target) {
                    ans.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));

                    // 现在要增加 left，减小 right
                    left++;
                    right--; // 首先无论如何先要进行加减操作
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } else if (nums[left] + nums[right] < target) {
                    left++;
                } else {  // nums[left] + nums[right] > target
                    right--;
                }
            }
        }
        return ans;
    }
}
```

## 17.电话号码的字母组合

### leetcode 题解

#### 解题思路

首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。

回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。

回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。

#### 代码

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }

    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        } else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            int lettersCount = letters.length();
            for (int i = 0; i < lettersCount; i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}
```

## 19.删除链表的倒数第 N 个结点

### 我的题解

#### 解题思路

先遍历一边链表，将链表的每个节点都存入 ArrayList，然后取出要删除节点的前一个节点进行删除操作。

**tip：一般添加一个哑节点(dummy node)，它的$\textit{next}$指针指向头节点。这样一来，我们就不需要对头节点进行特殊的判断了。**

#### 代码

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        List<ListNode> nodeList = new ArrayList<ListNode>();
        ListNode p = head;
        while (p != null) {
            nodeList.add(p);
            p = p.next;
        }
        if (nodeList.size() == 1) {
            return null;
        }
        if (n == nodeList.size()) {
            return head.next;
        }
        p = nodeList.get(nodeList.size() - n - 1);
        p.next = p.next.next;
        return head;
    }
}
```

## 20.有效的括号

### 我的题解

#### 解题思路

用栈实现，用循环首先是否为( { [,是的话就压入栈，再判断是否为) } ]是的话就看与出栈的元素是否匹配，最后如果 arr 为空，就说明括号有效

#### 代码

```java
class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        Map<Character, Character> pairs = new HashMap<Character, Character>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};
        Deque<Character> stack = new LinkedList<Character>();
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (pairs.containsKey(ch)) {
                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) {
                    return false;
                }
                stack.pop();
            } else {
                stack.push(ch);
            }
        }
        return stack.isEmpty();
    }
}
```

## 21.合并两个有序链表

### 我的题解

#### 解题思路

逐个比较两链表节点，比较大小,用另一个链表存储节点

#### 代码

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);
        ListNode res = head;
        while (l1 != null && l2 != null) {
            if (l1.val > l2.val) {
                head.next = l2;
                l2 = l2.next;
            } else {
                head.next = l1;
                l1 = l1.next;
            }
            head = head.next;
        }
        if (l1 != null) {
            head.next = l1;
        }
        if (l2 != null) {
            head.next = l2;
        }
        return res.next;
    }
}
```

## 22.括号生成

### leetcode 题解

#### 解题思路

回溯算法(深度优先遍历)

![](https://cansiny.oss-cn-shanghai.aliyuncs.com/images/1613645674227.png)

#### 代码

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<String>();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max) {
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }
        if (open < max) {
            cur.append("(");
            backtrack(ans, cur, open + 1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }

        if (close < open) {
            cur.append(")");
            backtrack(ans, cur, open, close + 1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
```

## 23.合并 K 个升序列表

### leetcode 题解

#### 解题思路

分治合并 将 k 个链表两两一组分别合并，不断重复，最终得到有序列表

注意 配对的时候不是顺序的依次配对 而是从类似于二分查找一样的从中间分,最后找到两个链表合并

![](https://cansiny.oss-cn-shanghai.aliyuncs.com/images/1613826638889.png)

#### 代码

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);
        ListNode res = head;
        while (l1 != null && l2 != null) {
            if (l1.val > l2.val) {
                head.next = l2;
                l2 = l2.next;
            } else {
                head.next = l1;
                l1 = l1.next;
            }
            head = head.next;
        }
        if (l1 != null) {
            head.next = l1;
        }
        if (l2 != null) {
            head.next = l2;
        }
        return res.next;
    }

    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int l, int r) {
        if (l == r) {
            return lists[l];
        }
        if (l > r) {
            return null;
        }

        int mid = (l + r) / 2;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

}
```

## 31.下一个排列

### leetcode 题解

#### 解题思路

如何得到一个紧邻的下一个排列？

1. 首先我们要希望**下一个数要比当前这个数大**，所以我们只需要将**后面的大数与前面的小数交换**。比如 `123456`，将 `5` 和 `6` 交换就能得到一个更大的数 `123465`。
2. 我们还希望下一个数**增加的幅度尽可能小**，这样才能得到紧邻的下一个数。为了满足这个要求，我们需要：
   1. 尽可能的交换靠右的低位，所以需要**从后往前遍历**
   2. 将尽可能小的大数与前面的小数交换。比如 `123465`，下一个排列应该把 `5` 和 `4` 交换而不是把 `6` 和 `4` 交换
   3. 将大数换到前面后，需要将大数后面的数重置为升序排列。以 `123465` 为例：首先按照上一步，交换 `5` 和 `4`，得到 `123564`；然后需要将 `5` 之后的数重置为升序，得到 `123546`。显然 `123546` 比 `123564` 更小，`123546` 就是 `123465` 的下一个排列

算法实现上来说

1. 首先从后往前遍历，找到第一组相邻的升序元素对`(i,j)`，`A[i] < A[j]`。此时`[j,end)`一定是降序。
2. 在 [j,end) 从后向前查找第一个满足 A[i] < A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」
3. 将 A[i] 与 A[k] 交换
4. 可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序
5. 如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4

#### 代码

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int length = nums.length;
        int i, j, k = 0;
        for (i = length - 1; i > 0; i--) {
            if (nums[i] > nums[i - 1]) {
                k = i;
                for (j = length - 1; j >= k; j--) {
                    if (nums[j] > nums[k - 1]) {
                        int temp = nums[j];
                        nums[j] = nums[k - 1];
                        nums[k - 1] = temp;
                        break;
                    }
                }

                break;
            }
        }
        for (i = k, j = length - 1; i < j; i++, j--) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
}
```

## 32.最长有效括号

### leetcode 题解

#### 解题思路

动态规划

定义`dp[i]`为以下标 i 的字符结尾的最长有效括号的长度。

对于`dp[i]`有两种情况：

- 如果`s[i]`为`(`:

  `s[i]`无法和其之前的元素组成有效的括号对，`dp[i] = 0`,可以直接忽略

- 如果`s[i]`为`)`:

  此时我们需要对元素来判断是否有有效括号对。

  通过比较和下标为 i 的元素配对的下标为`i - dp[i-1] - 1`的元素 与当前的右括号相匹配的左括号位置：前面有效括号长度再往前一个位置

  如果`s[i - dp[i-1] - 1]`为`'('` : 则有：$dp[i] = dp[i-1] + 2$

  注意 此时，需要再往前看下，是否还有有效长度，如果有，合并过来

  例如：`"()(()())"` 当前在计算最后一个位置时，`dp[7]`已经等于 `dp[6]+2 = 4+2`

  但需要再往前看一眼，`dp[1]`还有有效长度，合并过来 `dp[7] = 4+2+2`

  那是否还需要再往前看？

  不需要了，因为，如果前面还有有效长度，其长度肯定已经合并到 `dp[2]`上了

  因此，每次只需要再往前多看一眼就可以

#### 代码

```java
class Solution {
    public static int longestValidParentheses(String s) {
        int length = s.length();
        if (length < 2) return 0;

        int[] dp = new int[length];
        int ans = 0;

        for (int i = 1; i < length; i++) {
            if (s.charAt(i) == ')') {
                int preLen = dp[i - 1];
                int pre = i - preLen - 1; // 寻找与当前的右括号相匹配的左括号位置：前面有效括号长度再往前一个位置
                if (pre >= 0 && s.charAt(pre) == '(') {
                    dp[i] = dp[i - 1] + 2;
                    if (pre - 1 >= 0) {
                        dp[i] += dp[pre - 1];
                    }
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

## 33.搜索旋转排序数组

### 解题思路

**二分查找**

虽然数组不是完全有序的，但是当我们将数组从中间分开的时候，会出现一部分有序，一部分可能有序的情况。

对于有序的部分我们任然可以使用二分查找：

- 如果 `[l,mid]` 是有序数组，且 `target` 满足 `[nums[l],nums[mid]]` ，我们应该将搜索范围缩小到 `[l,mid-1]` ，否则在 `[mid+1,r]` 中寻找
- 如果 `[mid+1,r]` 是有序数组，且 `target` 满足 `[nums[mid+1],nums[r]]` ，我们应该将搜索范围缩小到 `[mid+1,r]` ，否则在 `[l,mid-1]` 中寻找

![](https://cansiny.oss-cn-shanghai.aliyuncs.com/images/1614926960973.png)

需要注意的是 判断左右那部分是有序的时候，可以直接比较 `nums[l]` 和 `nums[target]` 或者是 `nums[r]` 和 `nums[target]`,不需要遍历比较

### 代码

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[r]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}
```
