---
id: hot100
title: HOT 100
# hide_title: false
# hide_table_of_contents: false
# sidebar_label: Markdown :)
# custom_edit_url: https://github.com/facebook/docusaurus/edit/master/docs/api-doc-markdown.md
description: LeetCode 热题 HOT 100
keywords:
  - JavaScript
  - Java
  - 数据结构和算法
# image: https://i.imgur.com/mErPwqL.png
---

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

### 我的题解

#### 解题思路

直接暴力枚举两层 for 循环，判断相加是否与 target 相等

#### 代码

js

```js
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = 0; j < nums.length; j++) {
      if (i !== j) {
        if (nums[i] + nums[j] === target) return [i, j];
      }
    }
  }
};
```

java

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        int[] arr = new int[2];
        for (int i = 0; i < nums.length; i++) {
            for(int j = 0 ;j < nums.length ;j++) {
                if( i != j ) {
                    if(nums[i] + nums[j] == target){
                        arr[0] = i;
                        arr[1] = j;
                    }
                }
            }
        }
        return arr;
    }
}
```

### leetcode 题解

#### 解题思路

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

#### 代码

js

```js
var twoSum = function (nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i];
    }
    map.set(nums[i], i);
  }
  return [];
};
```

java

```java
class Solution {
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            if(hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]),i};
            }
            hashtable.put(nums[i],i);
        }
        return new int[0];
    }
}
```

## 2.两数相加

### 我的题解

#### 解题思路

先遍历两个链表，按权值乘每位数字，最后相加得到相加后的结果。然后使用栈方法，将结果的数字从低位到高位一个一个出栈。

注意计算$10^{n}$时需处理大数问题

#### 代码

js

```js
var addTwoNumbers = function (l1, l2) {
  let p1 = l1;
  let p2 = l2;
  let pow1 = 0;
  let pow2 = 0;
  let result = 0n;

  while (p1 !== null) {
    let pows = 1n;
    for (let i = 0; i < pow1; i++) {
      pows *= 10n;
    }
    result += pows * BigInt(p1.val);
    pow1++;
    p1 = p1.next;
  }
  while (p2 !== null) {
    let pows = 1n;
    for (let i = 0; i < pow2; i++) {
      pows *= 10n;
    }
    result += pows * BigInt(p2.val);
    pow2++;
    p2 = p2.next;
  }
  result = result.toString().split("");
  if (result.length === 1) {
    return new ListNode(result.pop(), null);
  } else {
    const head = new ListNode(result.pop(), null);
    let p = head;
    while (result.length) {
      const node = new ListNode(result.pop(), null);
      p.next = node;
      p = node;
    }
    return head;
  }
};
```

### leetcode 题解

#### 解题思路

由于输入的两个链表都是**逆序**存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。

我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为$n1,n2$，进位值为 $\textit{carry}$，则它们的和为 $n1+n2+\textit{carry}$；其中，答案链表处相应位置的数字为$(n1+n2+\textit{carry}) \% 10$，而新的进位值为 $\lfloor\frac{n1+n2+\textit{carry}}{10}\rfloor$。

如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个$0$ 。

此外，如果链表遍历结束后，有$\textit{carry} > 0$，还需要在答案链表的后面附加一个节点，节点的值为 $\textit{carry}$。

#### 代码

js

```js
var addTwoNumbers = function (l1, l2) {
  let head = null,
    tail = null;
  let carry = 0;
  while (l1 || l2) {
    const n1 = l1 ? l1.val : 0;
    const n2 = l2 ? l2.val : 0;
    const sum = n1 + n2 + carry;
    if (!head) {
      head = tail = new ListNode(sum % 10);
    } else {
      tail.next = new ListNode(sum % 10);
      tail = tail.next;
    }
    carry = Math.floor(sum / 10);
    if (l1) {
      l1 = l1.next;
    }
    if (l2) {
      l2 = l2.next;
    }
  }
  if (carry > 0) {
    tail.next = new ListNode(carry);
  }
  return head;
};
```

java

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}
```
